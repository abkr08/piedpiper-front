{"ast":null,"code":"import { store } from '../../../index';\nimport * as actionTypes from '../actions';\nimport io from 'socket.io-client';\nvar name;\nvar connectedUser;\nvar userId = localStorage.getItem('userId');\nvar config = {}; //connecting to our signaling server\n\nvar conn = io('http://localhost:8082');\nvar configuration = {\n  \"iceServers\": [{\n    \"url\": \"stun:stun2.1.google.com:19302\"\n  }]\n};\nvar offerOptions = {\n  offerToReceiveAudio: 1,\n  offerToReceiveVideo: 1\n};\nvar yourConn;\nvar stream = null;\nconsole.log(conn);\nconn.on('connection', function () {\n  console.log(\"Connected to the signaling server\");\n});\n\nvar prepareCaller = function prepareCaller(channel) {\n  return {\n    type: actionTypes.PREPARE_CALLER,\n    channel: channel\n  };\n};\n\nexport var getCallerReady = function getCallerReady() {\n  return function (dispatch) {\n    send({\n      type: \"login\",\n      name: userId\n    });\n    dispatch(prepareCaller(conn));\n  };\n}; //when we got a message from a signaling server \n\nconn.on('message', function (msg) {\n  console.log(\"Got message\", msg);\n  var data = JSON.parse(msg);\n\n  switch (data.type) {\n    case \"login\":\n      //  handleLogin(data.success); \n      console.log('logged in');\n      break;\n\n    case \"requestToCall\":\n      //prepare user for call\n      console.log('received a request from ' + data.from);\n      handleRequest(data.from);\n      break;\n\n    case \"answerToRequest\":\n      //user is ready...send them an offer\n      console.log('received an answer from ' + data.from);\n      createOffer(data.from);\n      break;\n    //when somebody wants to call us \n\n    case \"offer\":\n      handleOffer(data.offer, data.name);\n      break;\n\n    case \"answer\":\n      handleAnswer(data.answer, data.from);\n      break;\n    //when a remote peer sends an ice candidate to us \n\n    case \"candidate\":\n      handleCandidate(data.candidate);\n      break;\n\n    case \"leave\":\n      handleLeave();\n      break;\n\n    default:\n      break;\n  }\n});\n\nconn.onerror = function (err) {\n  console.log(\"Got error\", err);\n};\n\nvar createOffer = function createOffer(to) {\n  // create an offer \n  yourConn.createOffer(function (offer) {\n    send({\n      type: \"offer\",\n      offer: offer\n    });\n    yourConn.setLocalDescription(offer);\n  }, function (error) {\n    alert(\"Error when creating an offer\");\n  });\n};\n\nvar handleRequest = function handleRequest(from) {\n  store.dispatch({\n    type: actionTypes.ON_INCOMING_CALL,\n    callType: 'video',\n    caller: from\n  });\n  yourConn = new RTCPeerConnection(configuration); //when a remote user adds stream to the peer connection, we display it \n\n  yourConn.ontrack = function (stream) {\n    console.log('got remote stream');\n    console.log(stream);\n    store.dispatch(onTrack(stream));\n  };\n\n  console.log(yourConn); // Setup ice handling \n\n  yourConn.onicecandidate = function (event) {\n    if (event.candidate) {\n      send({\n        type: \"candidate\",\n        candidate: event.candidate\n      });\n    }\n  };\n\n  getMedia().then(gotStream).catch(function (err) {\n    return console.log(err);\n  });\n  send({\n    type: 'answerToRequest',\n    from: userId\n  });\n}; //alias for sending JSON encoded messages \n\n\nfunction send(message) {\n  //attach the other peer username to our messages \n  alert(connectedUser);\n\n  if (connectedUser) {\n    message.name = connectedUser;\n  }\n\n  conn.send(JSON.stringify(message));\n}\n\n;\n\nvar getMedia = function getMedia() {\n  return navigator.mediaDevices.getUserMedia({\n    video: {\n      width: 1280,\n      height: 720,\n      frameRate: 15\n    },\n    // config.callType === 'video' ? {width: 1280,\n    //     height: 720,\n    //     frameRate: 15}: false,\n    audio: true\n  });\n};\n\nexport var callUser = function callUser(user, type) {\n  connectedUser = user;\n  config.type = type;\n  console.log('calling ' + user + '....');\n  return function (dispatch) {\n    yourConn = new RTCPeerConnection(configuration); //when a remote user adds stream to the peer connection, we display it \n\n    yourConn.ontrack = function (stream) {\n      console.log('got remote stream');\n      console.log(stream);\n      store.dispatch(onTrack(stream));\n    };\n\n    console.log(yourConn); // Setup ice handling \n\n    yourConn.onicecandidate = function (event) {\n      if (event.candidate) {\n        send({\n          type: \"candidate\",\n          candidate: event.candidate\n        });\n      }\n    };\n\n    getMedia().then(gotStream).catch(function (e) {\n      return console.log(\"getUserMedia() error: \".concat(e));\n    });\n    dispatch({\n      type: actionTypes.CALL_INIT\n    });\n    send({\n      type: 'requestToCall',\n      from: userId\n    });\n  };\n};\n\nvar gotStream = function gotStream(myStream) {\n  console.log('Received local stream');\n  stream = myStream;\n  store.dispatch(onLocalStream(myStream));\n  myStream.getTracks().forEach(function (track) {\n    console.log(track);\n    yourConn.addTrack(track, myStream);\n  });\n};\n\nvar onTrack = function onTrack(track) {\n  return {\n    type: actionTypes.ON_TRACK,\n    remoteStream: track.streams[0]\n  };\n};\n\nvar onLocalStream = function onLocalStream(stream) {\n  return {\n    type: actionTypes.ON_LOCAL_STREAM,\n    stream: stream\n  };\n};\n\nfunction handleOffer(offer, name) {\n  connectedUser = name;\n  console.log('Accepting offer from ' + connectedUser);\n  yourConn.setRemoteDescription(new RTCSessionDescription(offer)); //create an answer to an offer \n\n  console.log('Creating and sending answer to ' + connectedUser);\n  yourConn.createAnswer(function (answer) {\n    yourConn.setLocalDescription(answer);\n    send({\n      type: \"answer\",\n      answer: answer,\n      from: name\n    });\n  }, function (error) {\n    alert(\"Error when creating an answer\");\n  });\n}\n\nexport var callAccepted = function callAccepted() {\n  return function (dispatch) {\n    dispatch({\n      type: actionTypes.CALL_ACCEPTED\n    });\n  };\n};\nexport var callRejected = function callRejected() {\n  return function (dispatch) {\n    // channel.trigger(\"client-reject\", { room: config.room, rejected: userId });\n    dispatch({\n      type: actionTypes.CALL_REJECTED\n    });\n  };\n};\n\nfunction handleAnswer(answer, name) {\n  console.log('Accepting answer from ' + name);\n  connectedUser = name;\n  yourConn.setRemoteDescription(new RTCSessionDescription(answer));\n}\n\n;\n\nfunction handleCandidate(candidate) {\n  yourConn.addIceCandidate(new RTCIceCandidate(candidate));\n}\n\n;\nexport var endCall = function endCall() {\n  return function (dispatch) {\n    send({\n      type: \"leave\",\n      name: name\n    });\n    handleLeave();\n  };\n};\n\nfunction handleLeave() {\n  connectedUser = null;\n  stream.getTracks().forEach(function (track) {\n    return track.stop();\n  });\n  yourConn.close();\n  yourConn.onicecandidate = null;\n  yourConn.onaddTrack = null;\n}\n\n;","map":{"version":3,"sources":["/Users/Gotzil/Desktop/React/PiperChat/piedpiper/client/src/store/actions/actionCreators/callActionCreatorss.js"],"names":["store","actionTypes","io","name","connectedUser","userId","localStorage","getItem","config","conn","configuration","offerOptions","offerToReceiveAudio","offerToReceiveVideo","yourConn","stream","console","log","on","prepareCaller","channel","type","PREPARE_CALLER","getCallerReady","dispatch","send","msg","data","JSON","parse","from","handleRequest","createOffer","handleOffer","offer","handleAnswer","answer","handleCandidate","candidate","handleLeave","onerror","err","to","setLocalDescription","error","alert","ON_INCOMING_CALL","callType","caller","RTCPeerConnection","ontrack","onTrack","onicecandidate","event","getMedia","then","gotStream","catch","message","stringify","navigator","mediaDevices","getUserMedia","video","width","height","frameRate","audio","callUser","user","e","CALL_INIT","myStream","onLocalStream","getTracks","forEach","track","addTrack","ON_TRACK","remoteStream","streams","ON_LOCAL_STREAM","setRemoteDescription","RTCSessionDescription","createAnswer","callAccepted","CALL_ACCEPTED","callRejected","CALL_REJECTED","addIceCandidate","RTCIceCandidate","endCall","stop","close","onaddTrack"],"mappings":"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","sourcesContent":["import { store }  from '../../../index';\nimport * as actionTypes from '../actions';\nimport io from 'socket.io-client'; \n\nlet name; \nlet connectedUser;\nconst userId = localStorage.getItem('userId');\nconst config = {};\n\n//connecting to our signaling server\nconst conn = io('http://localhost:8082')\nconst configuration = { \n    \"iceServers\": [{ \"url\": \"stun:stun2.1.google.com:19302\" }]\n};\nconst offerOptions = {\n    offerToReceiveAudio: 1,\n    offerToReceiveVideo: 1\n};\nlet yourConn;\nlet stream = null;\n\nconsole.log(conn);\nconn.on('connection', function () { \n   console.log(\"Connected to the signaling server\"); \n});\n\nconst prepareCaller = channel => {\n    return {\n        type: actionTypes.PREPARE_CALLER,\n        channel: channel\n    }\n}\nexport const getCallerReady = () => {\n    return dispatch => {\n        send({ \n            type: \"login\", \n            name: userId\n         });   \n        dispatch(prepareCaller(conn));\n    }\n}\n//when we got a message from a signaling server \nconn.on('message', function (msg) { \n\n   console.log(\"Got message\", msg);\n\t\n   const data = JSON.parse(msg); \n\t\n   switch(data.type) { \n    case \"login\": \n        //  handleLogin(data.success); \n        console.log('logged in')\n        break; \n    case \"requestToCall\":\n        //prepare user for call\n        console.log('received a request from ' + data.from);\n        handleRequest(data.from); \n        break;\n    case \"answerToRequest\":\n        //user is ready...send them an offer\n        console.log('received an answer from ' + data.from);\n        createOffer(data.from); \n        break;\n\n    //when somebody wants to call us \n    case \"offer\": \n        handleOffer(data.offer, data.name)\n        break; \n    case \"answer\": \n        handleAnswer(data.answer, data.from); \n        break; \n    //when a remote peer sends an ice candidate to us \n    case \"candidate\": \n        handleCandidate(data.candidate); \n        break; \n    case \"leave\": \n        handleLeave(); \n        break; \n    default: \n        break; \n   }\n});\n  \nconn.onerror = function (err) { \n   console.log(\"Got error\", err); \n};\n\nconst createOffer = to => {\n    // create an offer \n    yourConn.createOffer(function (offer) { \n        send({ \n            type: \"offer\", \n            offer: offer \n        }); \n            \n        yourConn.setLocalDescription(offer); \n        }, function (error) { \n        alert(\"Error when creating an offer\"); \n        });\n}\nconst handleRequest = from => {\n    store.dispatch({type: actionTypes.ON_INCOMING_CALL, callType: 'video', caller: from});\n    yourConn = new RTCPeerConnection(configuration);\n        \n        //when a remote user adds stream to the peer connection, we display it \n        yourConn.ontrack = function (stream) { \n            console.log('got remote stream');\n            console.log(stream)\n        store.dispatch(onTrack(stream));\n        };\n        console.log(yourConn);\n        // Setup ice handling \n        yourConn.onicecandidate = function (event) { \n        if (event.candidate) { \n            send({ \n                type: \"candidate\", \n                candidate: event.candidate\n            }); \n        } \n        }\n    getMedia().then(gotStream).catch(err => console.log(err));\n    send({\n        type: 'answerToRequest',\n        from: userId\n    })\n}\n//alias for sending JSON encoded messages \nfunction send(message) { \n   //attach the other peer username to our messages \n   alert(connectedUser);\n   if (connectedUser) { \n      message.name = connectedUser; \n   } \n\t\n   conn.send(JSON.stringify(message)); \n};\n\nconst getMedia = () => {\n    return navigator.mediaDevices.getUserMedia({\n        video: {width: 1280,\n                height: 720,\n                frameRate: 15},\n        // config.callType === 'video' ? {width: 1280,\n        //     height: 720,\n        //     frameRate: 15}: false,\n        audio: true\n      });\n}\n\nexport const callUser = (user, type) => {\n    connectedUser = user;\n    config.type = type;\n    console.log('calling ' + user + '....' );\n    return dispatch => {\n        yourConn = new RTCPeerConnection(configuration);\n        \n        //when a remote user adds stream to the peer connection, we display it \n        yourConn.ontrack = function (stream) { \n            console.log('got remote stream');\n            console.log(stream)\n        store.dispatch(onTrack(stream));\n        };\n        console.log(yourConn);\n        // Setup ice handling \n        yourConn.onicecandidate = function (event) { \n        if (event.candidate) { \n            send({ \n                type: \"candidate\", \n                candidate: event.candidate\n            }); \n        } \n        }\n        getMedia().then(gotStream)\n        .catch(e => console.log(`getUserMedia() error: ${e}`));\n        dispatch({type: actionTypes.CALL_INIT})\n        send({\n            type: 'requestToCall',\n            from: userId\n        })        \n    }\n  }  \n\nconst gotStream = myStream => {\n    console.log('Received local stream');\n    stream = myStream;\n    store.dispatch(onLocalStream(myStream));\n    myStream.getTracks().forEach(track => {\n        console.log(track);\n            yourConn.addTrack(track, myStream)\n        });\n}\n\nconst onTrack = track => {\n    return {\n        type: actionTypes.ON_TRACK,\n        remoteStream: track.streams[0]\n    }\n}\n\nconst onLocalStream = stream => {\n    return {\n        type: actionTypes.ON_LOCAL_STREAM,\n        stream: stream\n    }\n}\nfunction handleOffer(offer, name) { \n    connectedUser = name; \n    console.log('Accepting offer from ' + connectedUser);\n    yourConn.setRemoteDescription(new RTCSessionDescription(offer));\n     \n    //create an answer to an offer \n    console.log('Creating and sending answer to ' + connectedUser);\n    yourConn.createAnswer(function (answer) { \n        yourConn.setLocalDescription(answer); \n        send({ \n            type: \"answer\", \n            answer: answer,\n            from: name \n       }); \n         \n    }, function (error) { \n       alert(\"Error when creating an answer\"); \n    }); \n}\nexport const callAccepted = () => {\n    return dispatch => {\n        dispatch({type: actionTypes.CALL_ACCEPTED})\n    }\n}\nexport const callRejected = () => {\n    return dispatch => {\n        // channel.trigger(\"client-reject\", { room: config.room, rejected: userId });\n        dispatch({type: actionTypes.CALL_REJECTED})\n    }\n}\nfunction handleAnswer(answer, name) { \n    console.log('Accepting answer from ' + name)\n    connectedUser = name;\n   yourConn.setRemoteDescription(new RTCSessionDescription(answer)); \n};\nfunction handleCandidate(candidate) { \n    yourConn.addIceCandidate(new RTCIceCandidate(candidate)); \n };\n\nexport const endCall = () => {\n    return dispatch => {\n        send({ \n            type: \"leave\",\n            name: name \n         }); \n        handleLeave(); \n    }\n}\n\nfunction handleLeave() { \n    connectedUser = null; \n    stream.getTracks().forEach(track => track.stop());\n     \n    yourConn.close(); \n    yourConn.onicecandidate = null; \n    yourConn.onaddTrack = null;\n };"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { store } from '../../../index';\nimport * as actionTypes from '../actions';\nvar name;\nvar connectedUser; //connecting to our signaling server\n\nvar conn = io('http://localhost:8082');\nvar configuration = {\n  \"iceServers\": [{\n    \"url\": \"stun:stun2.1.google.com:19302\"\n  }]\n};\nvar yourConn = new RTCPeerConnection(configuration);\nconsole.log(conn);\nconn.on('connection', function () {\n  console.log(\"Connected to the signaling server\");\n});\n\nvar prepareCaller = function prepareCaller(channel) {\n  return {\n    type: actionTypes.PREPARE_CALLER,\n    channel: channel\n  };\n};\n\nexport var getCallerReady = function getCallerReady() {\n  return function (dispatch) {\n    //when a remote user adds stream to the peer connection, we display it \n    yourConn.ontrack = function (stream) {\n      console.log('got remote stream');\n      console.log(e);\n      dispatch(onTrack(stream));\n    }; // Setup ice handling \n\n\n    yourConn.onicecandidate = function (event) {\n      if (event.candidate) {\n        send({\n          type: \"candidate\",\n          candidate: event.candidate\n        });\n      }\n    };\n\n    dispatch(prepareCaller(conn));\n  };\n}; //when we got a message from a signaling server \n\nconn.on('message', function (msg) {\n  console.log(\"Got message\", msg);\n  var data = JSON.parse(msg);\n\n  switch (data.type) {\n    case \"login\":\n      handleLogin(data.success);\n      break;\n    //when somebody wants to call us \n\n    case \"offer\":\n      setTimeout(function () {\n        return handleOffer(data.offer, data.name);\n      }, 10000);\n      break;\n\n    case \"answer\":\n      handleAnswer(data.answer, data.from);\n      break;\n    //when a remote peer sends an ice candidate to us \n\n    case \"candidate\":\n      handleCandidate(data.candidate);\n      break;\n\n    case \"leave\":\n      handleLeave();\n      break;\n\n    default:\n      break;\n  }\n});\n\nconn.onerror = function (err) {\n  console.log(\"Got error\", err);\n}; //alias for sending JSON encoded messages \n\n\nfunction send(message) {\n  //attach the other peer username to our messages \n  if (connectedUser) {\n    message.name = connectedUser;\n  }\n\n  conn.send(JSON.stringify(message));\n}\n\n;\n\nvar getMedia = function getMedia() {\n  return navigator.mediaDevices.getUserMedia({\n    video: config.callType === 'video' ? {\n      width: 1280,\n      height: 720,\n      frameRate: 15\n    } : false,\n    audio: true\n  });\n};\n\nexport var callUser = function callUser(user, type) {\n  config.room = user;\n  console.log('calling ' + callToUsername + '....');\n  return function (dispatch) {\n    getMedia().then(gotStream).catch(function (e) {\n      return alert(\"getUserMedia() error: \".concat(e.name));\n    });\n    dispatch({\n      type: actionTypes.CALL_INIT\n    });\n    yourConn.createOffer(function (offer) {\n      send({\n        type: \"offer\",\n        offer: offer\n      });\n      yourConn.setLocalDescription(offer);\n    }, function (error) {\n      alert(\"Error when creating an offer\");\n    });\n  };\n};\n\nvar gotStream = function gotStream(stream) {\n  console.log('Received local stream');\n  store.dispatch(onLocalStream(stream));\n  stream.getTracks().forEach(function (track) {\n    caller.addTrack(track, stream);\n  });\n};\n\nvar onTrack = function onTrack(track) {\n  return {\n    type: actionTypes.ON_TRACK,\n    remoteStream: track.streams[0]\n  };\n};\n\nvar onLocalStream = function onLocalStream(stream) {\n  return {\n    type: actionTypes.ON_LOCAL_STREAM,\n    stream: stream\n  };\n};\n\nfunction handleOffer(offer, name) {\n  connectedUser = name;\n  console.log('Accepting offer from ' + connectedUser);\n  yourConn.setRemoteDescription(new RTCSessionDescription(offer)); //create an answer to an offer \n\n  console.log('Creating and sending answer to ' + connectedUser);\n  yourConn.createAnswer(function (answer) {\n    getMedia().then(gotStream);\n    yourConn.setLocalDescription(answer);\n    send({\n      type: \"answer\",\n      answer: answer,\n      from: name\n    });\n  }, function (error) {\n    alert(\"Error when creating an answer\");\n  });\n}\n\nexport var callAccepted = function callAccepted() {\n  return function (dispatch) {\n    dispatch({\n      type: actionTypes.CALL_ACCEPTED\n    });\n  };\n};\nexport var callRejected = function callRejected() {\n  return function (dispatch) {\n    // channel.trigger(\"client-reject\", { room: config.room, rejected: userId });\n    dispatch({\n      type: actionTypes.CALL_REJECTED\n    });\n  };\n};\n\nfunction handleAnswer(answer, name) {\n  console.log('Accepting answer from ' + name);\n  yourConn.setRemoteDescription(new RTCSessionDescription(answer));\n}\n\n;\n\nfunction handleCandidate(candidate) {\n  yourConn.addIceCandidate(new RTCIceCandidate(candidate));\n}\n\n;\n\nvar endCall = function endCall() {\n  send({\n    type: \"leave\",\n    name: name\n  });\n  handleLeave();\n};\n\nfunction handleLeave() {\n  connectedUser = null;\n  stream.getTracks().forEach(function (track) {\n    return track.stop();\n  });\n  yourConn.close();\n  yourConn.onicecandidate = null;\n  yourConn.onaddTrack = null;\n}\n\n;","map":{"version":3,"sources":["/Users/Gotzil/Desktop/React/PiperChat/piedpiper/client/src/store/actions/actionCreators/callActionCreatorss.js"],"names":["store","actionTypes","name","connectedUser","conn","io","configuration","yourConn","RTCPeerConnection","console","log","on","prepareCaller","channel","type","PREPARE_CALLER","getCallerReady","dispatch","ontrack","stream","e","onTrack","onicecandidate","event","candidate","send","msg","data","JSON","parse","handleLogin","success","setTimeout","handleOffer","offer","handleAnswer","answer","from","handleCandidate","handleLeave","onerror","err","message","stringify","getMedia","navigator","mediaDevices","getUserMedia","video","config","callType","width","height","frameRate","audio","callUser","user","room","callToUsername","then","gotStream","catch","alert","CALL_INIT","createOffer","setLocalDescription","error","onLocalStream","getTracks","forEach","track","caller","addTrack","ON_TRACK","remoteStream","streams","ON_LOCAL_STREAM","setRemoteDescription","RTCSessionDescription","createAnswer","callAccepted","CALL_ACCEPTED","callRejected","CALL_REJECTED","addIceCandidate","RTCIceCandidate","endCall","stop","close","onaddTrack"],"mappings":"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","sourcesContent":["import { store }  from '../../../index';\nimport * as actionTypes from '../actions';\nlet name; \nlet connectedUser;\n  \n//connecting to our signaling server\nconst conn = io('http://localhost:8082')\nconst configuration = { \n    \"iceServers\": [{ \"url\": \"stun:stun2.1.google.com:19302\" }]\n };   \nconst yourConn = new RTCPeerConnection(configuration);\nconsole.log(conn);\nconn.on('connection', function () { \n   console.log(\"Connected to the signaling server\"); \n});\n\nconst prepareCaller = channel => {\n    return {\n        type: actionTypes.PREPARE_CALLER,\n        channel: channel\n    }\n}\nexport const getCallerReady = () => {\n    return dispatch => {\n        //when a remote user adds stream to the peer connection, we display it \n        yourConn.ontrack = function (stream) { \n            console.log('got remote stream');\n            console.log(e)\n           dispatch(onTrack(stream));\n        };\n           \n        // Setup ice handling \n        yourConn.onicecandidate = function (event) { \n           if (event.candidate) { \n              send({ \n                 type: \"candidate\", \n                 candidate: event.candidate \n              }); \n           } \n        };   \n        dispatch(prepareCaller(conn));\n    }\n}\n//when we got a message from a signaling server \nconn.on('message', function (msg) { \n\n   console.log(\"Got message\", msg);\n\t\n   const data = JSON.parse(msg); \n\t\n   switch(data.type) { \n      case \"login\": \n         handleLogin(data.success); \n         break; \n      //when somebody wants to call us \n      case \"offer\": \n         setTimeout(() => handleOffer(data.offer, data.name), 10000); \n         break; \n      case \"answer\": \n         handleAnswer(data.answer, data.from); \n         break; \n      //when a remote peer sends an ice candidate to us \n      case \"candidate\": \n         handleCandidate(data.candidate); \n         break; \n      case \"leave\": \n         handleLeave(); \n         break; \n      default: \n         break; \n   }\n});\n  \nconn.onerror = function (err) { \n   console.log(\"Got error\", err); \n};\n  \n//alias for sending JSON encoded messages \nfunction send(message) { \n   //attach the other peer username to our messages \n   if (connectedUser) { \n      message.name = connectedUser; \n   } \n\t\n   conn.send(JSON.stringify(message)); \n};\n\nconst getMedia = () => {\n    return navigator.mediaDevices.getUserMedia({\n        video: config.callType === 'video' ? {width: 1280,\n            height: 720,\n            frameRate: 15}: false,\n        audio: true\n      });\n}\n\nexport const callUser = (user, type) => {\n    config.room = user;\n    console.log('calling ' + callToUsername + '....' );\n    return dispatch => {\n        getMedia().then(gotStream)\n        .catch(e => alert(`getUserMedia() error: ${e.name}`));\n        dispatch({type: actionTypes.CALL_INIT})\n        yourConn.createOffer(function (offer) { \n            send({ \n               type: \"offer\", \n               offer: offer \n            }); \n               \n            yourConn.setLocalDescription(offer); \n         }, function (error) { \n            alert(\"Error when creating an offer\"); \n         });         \n    }\n  }  \n\nconst gotStream = stream => {\n    console.log('Received local stream');\n    store.dispatch(onLocalStream(stream));\n        stream.getTracks().forEach(track => {\n            caller.addTrack(track, stream)\n        });\n}\n\nconst onTrack = track => {\n    return {\n        type: actionTypes.ON_TRACK,\n        remoteStream: track.streams[0]\n    }\n}\n\nconst onLocalStream = stream => {\n    return {\n        type: actionTypes.ON_LOCAL_STREAM,\n        stream: stream\n    }\n}\nfunction handleOffer(offer, name) { \n    connectedUser = name; \n \n    console.log('Accepting offer from ' + connectedUser);\n    yourConn.setRemoteDescription(new RTCSessionDescription(offer));\n     \n    //create an answer to an offer \n    console.log('Creating and sending answer to ' + connectedUser);\n    yourConn.createAnswer(function (answer) { \n        getMedia().then(gotStream);\n        yourConn.setLocalDescription(answer); \n         \n        send({ \n            type: \"answer\", \n            answer: answer,\n            from: name \n       }); \n         \n    }, function (error) { \n       alert(\"Error when creating an answer\"); \n    }); \n}\nexport const callAccepted = () => {\n    return dispatch => {\n        dispatch({type: actionTypes.CALL_ACCEPTED})\n    }\n}\nexport const callRejected = () => {\n    return dispatch => {\n        // channel.trigger(\"client-reject\", { room: config.room, rejected: userId });\n        dispatch({type: actionTypes.CALL_REJECTED})\n    }\n}\nfunction handleAnswer(answer, name) { \n    console.log('Accepting answer from ' + name)\n   yourConn.setRemoteDescription(new RTCSessionDescription(answer)); \n};\nfunction handleCandidate(candidate) { \n    yourConn.addIceCandidate(new RTCIceCandidate(candidate)); \n };\n\n const endCall = () => {\n    send({ \n        type: \"leave\",\n        name: name \n     });  \n      \n     handleLeave(); \n}\n\nfunction handleLeave() { \n    connectedUser = null; \n    stream.getTracks().forEach(track => track.stop());\n     \n    yourConn.close(); \n    yourConn.onicecandidate = null; \n    yourConn.onaddTrack = null;\n };"]},"metadata":{},"sourceType":"module"}